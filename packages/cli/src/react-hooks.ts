/**
 * React hooks for PostHog feature flags with local development overrides.
 * This is an optional utility that requires React and posthog-js/react.
 *
 * @fileoverview Provides React hooks that automatically switch between PostHog and local
 * feature flag configurations based on the development environment.
 */

/**
 * Type definition for PostHog's useFeatureFlagEnabled hook.
 * This avoids runtime dependencies on PostHog packages.
 */
type UseFeatureFlagEnabledHook = (flag: string) => boolean | undefined;

/**
 * Generic feature flag key type.
 * In practice, this will be constrained by your generated FeatureFlag type.
 */
export type FeatureFlag = string;

/**
 * Configuration object for local feature flag overrides.
 * This matches the structure generated by the hogsync generator.
 */
export type LocalFeatureFlagConfig = {
  /** The feature flag key (kebab-case) */
  key: string;
  /** Human-readable name for the feature flag */
  name: string;
  /** Whether the flag is enabled in local development */
  enabled: boolean;
};

/**
 * Auto-detects development mode across different React frameworks and environments.
 *
 * @returns true if running in development mode, false otherwise
 *
 * @remarks
 * Detection order:
 * 1. Vite: Checks `import.meta.env.DEV` and `import.meta.env.MODE`
 * 2. Next.js: Checks `NEXT_PUBLIC_NODE_ENV` and `NODE_ENV`
 * 3. Node.js: Checks `NODE_ENV`
 * 4. Browser: Checks hostname patterns (localhost, 127.0.0.1, .local, or has port)
 * 5. Default: Returns false if detection fails
 */
function detectDevelopmentMode(): boolean {
  // Vite
  if (
    typeof globalThis !== 'undefined' &&
    (globalThis as unknown as { import?: { meta?: { env?: Record<string, string> } } }).import?.meta
      ?.env
  ) {
    const env = (globalThis as unknown as { import: { meta: { env: Record<string, string> } } })
      .import.meta.env;
    return env.DEV === 'true' || env.MODE === 'development';
  }

  // Next.js (client-side and server-side)
  if (
    typeof process !== 'undefined' &&
    (process.env.NEXT_PUBLIC_NODE_ENV || process.env.NODE_ENV)
  ) {
    return (
      process.env.NEXT_PUBLIC_NODE_ENV === 'development' || process.env.NODE_ENV === 'development'
    );
  }

  // Node.js environments (Next.js server-side, CRA, etc.)
  if (typeof process !== 'undefined' && (process.env.NODE_ENV || process.env.REACT_APP_NODE_ENV)) {
    return (
      process.env.NODE_ENV === 'development' || process.env.REACT_APP_NODE_ENV === 'development'
    );
  }

  // Browser-based detection fallbacks
  if (typeof window !== 'undefined') {
    // Check for common development indicators
    return (
      window.location.hostname === 'localhost' ||
      window.location.hostname === '127.0.0.1' ||
      window.location.hostname.includes('.local') ||
      window.location.port !== '' // Development servers usually run on ports
    );
  }

  // Default to false if we can't detect
  return false;
}

/**
 * Creates a feature flag hook that respects local development overrides.
 *
 * @param usePostHogFeatureFlagEnabled - The PostHog React hook (pass this in to avoid hard dependency)
 * @param LocalFeatureFlags - The generated local feature flags object
 * @param isDevelopment - Whether we're in development mode (auto-detects if not provided)
 * @param debug - Whether to log debug information (default: true)
 * @returns A React hook function that checks feature flag status
 *
 * @example
 * ```typescript
 * import { useFeatureFlagEnabled as usePostHogFeatureFlagEnabled } from "posthog-js/react";
 * import { LocalFeatureFlags } from "./generated/feature-flags";
 *
 * const useFeatureFlagEnabled = createUseFeatureFlagEnabled(
 *   usePostHogFeatureFlagEnabled,
 *   LocalFeatureFlags
 * );
 *
 * function MyComponent() {
 *   const isDarkModeEnabled = useFeatureFlagEnabled('dark-mode');
 *   return <div className={isDarkModeEnabled ? 'dark' : 'light'}>...</div>;
 * }
 * ```
 *
 * @remarks
 * - In development: Uses local flag configurations from JSON files
 * - In production: Uses PostHog's remote flag values
 * - Always calls the PostHog hook to comply with React's rules of hooks
 * - Automatically converts kebab-case flag keys to snake_case for local lookup
 * - Provides debug logging in development mode when enabled
 */
export function createUseFeatureFlagEnabled(
  usePostHogFeatureFlagEnabled: UseFeatureFlagEnabledHook,
  LocalFeatureFlags: Record<string, LocalFeatureFlagConfig>,
  isDevelopment?: boolean,
  debug = true
) {
  return function useFeatureFlagEnabled(flag: FeatureFlag): boolean {
    const isDevMode = isDevelopment ?? detectDevelopmentMode();

    // Always call the PostHog hook to comply with React rules of hooks
    const posthogEnabled = usePostHogFeatureFlagEnabled(flag);

    if (isDevMode) {
      const flagKey = flag.replace(/-/g, '_') as keyof typeof LocalFeatureFlags;
      const localConfig = LocalFeatureFlags[flagKey];

      if (debug && typeof console !== 'undefined') {
        const debugInfo = {
          framework: getFrameworkInfo(),
          isDevelopment: isDevMode,
          flagKey,
          localConfig,
          enabled: localConfig?.enabled,
          posthogEnabled: posthogEnabled ?? false,
        };
        console.log(
          `[Feature Flag Debug] ${flag}: framework: ${debugInfo.framework}, isDevelopment: ${debugInfo.isDevelopment}, enabled: ${debugInfo.enabled}`
        );
      }

      return localConfig?.enabled ?? false;
    }

    return posthogEnabled ?? false;
  };
}

/**
 * Detects the current React framework/environment for debugging purposes.
 *
 * @returns String identifier for the detected framework
 *
 * @internal
 * This function is used internally for debug logging to help developers
 * understand which environment detection path was used.
 */
function getFrameworkInfo(): string {
  if (
    typeof globalThis !== 'undefined' &&
    (globalThis as unknown as { import?: { meta?: { env?: Record<string, string> } } }).import?.meta
      ?.env
  ) {
    return 'vite';
  }
  if (typeof process !== 'undefined' && process.env.NEXT_PUBLIC_NODE_ENV) {
    return 'next.js';
  }
  if (typeof process !== 'undefined' && process.env.REACT_APP_NODE_ENV) {
    return 'create-react-app';
  }
  if (typeof window !== 'undefined') {
    return 'browser';
  }
  return 'unknown';
}

/**
 * Creates a function to get local feature flag configuration for a given flag.
 *
 * @param LocalFeatureFlags - The generated local feature flags object
 * @returns Function that retrieves local config for a flag key
 *
 * @example
 * ```typescript
 * import { LocalFeatureFlags } from "./generated/feature-flags";
 *
 * const getLocalFeatureFlagConfig = createGetLocalFeatureFlagConfig(LocalFeatureFlags);
 * const config = getLocalFeatureFlagConfig('dark-mode');
 * console.log(config?.enabled); // true/false or undefined
 * ```
 *
 * @remarks
 * - Automatically converts kebab-case flag keys to snake_case for lookup
 * - Returns undefined if the flag is not found in local configurations
 * - Useful for accessing flag metadata (name, description) in development
 */
export function createGetLocalFeatureFlagConfig(
  LocalFeatureFlags: Record<string, LocalFeatureFlagConfig>
) {
  return function getLocalFeatureFlagConfig(flag: FeatureFlag): LocalFeatureFlagConfig | undefined {
    const flagKey = flag.replace(/-/g, '_') as keyof typeof LocalFeatureFlags;
    return LocalFeatureFlags[flagKey];
  };
}

/**
 * Universal feature flags factory that works with any React setup
 * Auto-detects the framework and development environment
 * @param usePostHogFeatureFlagEnabled - The PostHog React hook
 * @param LocalFeatureFlags - The generated local feature flags object
 * @param options - Configuration options
 */
export function createFeatureFlags(
  usePostHogFeatureFlagEnabled: UseFeatureFlagEnabledHook,
  LocalFeatureFlags: Record<string, LocalFeatureFlagConfig>,
  options: {
    isDevelopment?: boolean;
    debug?: boolean;
  } = {}
) {
  const useFeatureFlagEnabled = createUseFeatureFlagEnabled(
    usePostHogFeatureFlagEnabled,
    LocalFeatureFlags,
    options.isDevelopment,
    options.debug ?? true
  );

  const getLocalFeatureFlagConfig = createGetLocalFeatureFlagConfig(LocalFeatureFlags);

  return {
    useFeatureFlagEnabled,
    getLocalFeatureFlagConfig,
    LocalFeatureFlags,
  };
}
